# Настоящий документ описывает протокол взаимодействия между головным устройством (далее - MASTER) и модулем расширения (далее - MODULE) от внешних разработчиков.

## MASTER - устройство, обеспечивающее взаимодействие с приложением по Bluethooth и считывание данных с датчиков, а также фильтрацию и калибровку данных
## MODULE - устройство, обеспечивающее работу с реальным физическим датчиком и нормирование сырых данных к значениям физической величины

* количество датчиков в рамках одного MODULE - от 1 и выше;
* количество каналов в рамках одного датчика - от 1 и выше;
* физический интерфейс для подключения MODULE к MASTER - UART в дуплексном режиме, скорость 115200;
* протокол команд - АТ;
* протокол данных - строковый протокол плоттера.

MASTER общается с MODULE посредством AT-команд. Протокол AT предполагает связь "точка-точка", одно устройство формирует запросы (ведущий, в нашем случае MASTER), второе устройство отвечает (ведомый, в нашем случае MODULE). Рассмотрим более подробно синтаксис АТ-команд:
АТ-команда представляет собой строку ASCII-символов в формате 'AT<COMMAND><SUFFIX><DATA>\r\n'. В начале всегда идёт префикс 'AT',
затем команда, далее - суффикс, определяющий тип команды, после - данные, в самом конце - завершающая последовательность '\r\n'.
Ответ на команду также представляет собой строку ASCII-символов возвращаемых данных в формате 'AT<COMMAND>:<DATA>\r\n', затем статус 'OK\r\n'. Если ответ не предполагает возврата каких-либо данных, то сразу возвращается статус 'OK\r\n' или 'ERROR\r\n'. Если возврат данных невозможен (был получен некорректный запрос от MASTER), то сразу возвращается статус 'ERROR'.
***
В широком смысле, AT-команды можно разделить на два формата: **Basic Commands** и **Extended Commands**.
* Basic Commands -эти команды не начинаются с '+'. Пример: 'ATCFG'. 
* Extended commands - эти команды начинаются с '+'. Пример: 'AT+CFG'.
В настоящем протоколе все команды в формате Extended для упрощения парсинга.
***
Кроме того, все АТ-команды делятся на 4 типа - **Test Commands**, **Read Commands**, **Set Commands** и **Execution Commands**.
Тип определяется суффиксом, согласно следующей таблице:
|Type      |Suffix | Назначение                               |
|----------|:-----:|------------------------------------------|
|Test      |=?     |Проверка поддержки ведомым данной команды |
|Read      |?      |Получение от ведомого настроек            |
|Set       |=      |Установка на ведомом настроек             |
|Execution |       |Запуск определённого действия             |

Ведомый отвечает на каждую команду данными (если они требуются) и статусом
## Test Commands
Эти команды позволяют узнать, поддерживает ли ведомый данную команду или нет. Синтаксис: 'AT<COMMAND_NAME>=?'.
Ведомый должен ответить 'OK' или, если команда не поддерживается, 'ERROR'.
Пример: 'AT+CFG=?' -> 'OK'.
## Read Commands
Эти команды служат для получения информации от ведомого. Синтаксис: 'AT<COMMAND_NAME>?'.
Ведомый должен вернуть список значений параметров и 'OK' или, если команда не поддерживается или запрос некорректен, сразу 'ERROR'.
Пример: 'AT+CFG?' -> 'AT+CFG:0,"OFF",11' 'OK'.
## Set Commands
Эти команды служат для установки настроек на ведомом. Синтаксис: 'AT<COMMAND_NAME>=<val1>,<val2>,...,<valN>'.
Ведомый должен ответить 'OK' в случае успешного применения настроек или 'ERROR' в случае ошибки.
Пример: 'AT+CFG=1,"ON",9' -> 'OK'.
## Execution Commands
Эти команды управляют работой ведомого. Синтаксис: 'AT<COMMAND_NAME>'.
Ведомый должен ответить 'OK' в случае успешного выполнения команды или 'ERROR' в случае ошибки.
Пример: 'AT+CFG' -> 'OK'.
***
Особняком стоит специализированная команда в формате 'AT'. Это команда для проверки связи с ведомым, ответ на неё должен быть 'OK'.
***
Ниже приведён список команд настоящего протокола и ожидаемые ответы:
|№  |Request from MASTER       |Command type |Response from MODULE                                                |
|---|:------------------------:|-------------|:------------------------------------------------------------------:|
|1  |'AT'                      |Check        |'OK'                                                                |
|2.1|'AT+SCFG=?'               |Test         |'OK'                                                                |
|2.2|'AT+SCFG?'                |Read         |'AT+SCFG:[<sensor_params>]&[...]' 'OK'                              |
|2.3|'AT+SCFG=<sensor_params>' |Set          |'OK' or 'ERROR'                                                     |
|3.1|'AT+PAS=?'                |Test         |'OK'                                                                |  
|3.2|'AT+PAS?'                 |Read         |'AT+PAS:<sensor_params>' 'OK' or 'AT+PAS:"NONE"' 'OK'               |
|4.1|'AT+SGAS=?                |Test         |'OK'                                                                |  
|4.2|'AT+SGAS'                 |Execution    |'OK' \<value(-s) in data format\>                                   |
|5.1|'AT+SPAS=?'               |Test         |'OK'                                                                |
|5.1|'AT+SPAS'                 |Execution    |'OK' \<value(-s) in data format\> \<value(-s) in data format\> ...  |
|6.1|'AT+BPAS=?'               |Test         |'OK'                                                                |
|6.1|'AT+BPAS'                 |Execution    |'OK'                                                                |

Требования к формату команд и ответов:
* Допустимые типы данных в параметрах - строка, целочисленное число, число с плавающей точкой.
* Числовые параметры с плавающей точкой используют в качестве разделителя между целочисленной и дробной частями точку, например: '3.14'
* Строковые параметры должны быть заключены в двойные кавычки, например: '3.14, "string", 9.8'.

Разберём подробнее структуру данных с параметрами датчика <sensor_params>. Она выглядит так: \<name\>,\<uuid\>,\<state\>,\<data_format\>,\<range_index\>,\<polling_period_ms\>.
* \<name\> - имя датчика в строковом формате. Пример: "Accelerometer".
* \<uuid\> - стандартный UUID датчика в строковом формате. Пример: "ba575001-eca0-11ec-8ea0-1337ac062022".  
* \<state\> - состояние датчика в строковом формате. Доступны следующие состояния:
    * "OFF" - датчик не активен. Это состояние всех датчиков по умолчанию.
    * "ON" - датчик активен. Только **ОДИН** датчик может быть активен в текущий момент. Текущий активированный датчик автоматически выключается при включении следующего.
* <data_format> - формат данных для выходных значений датчика в строковом формате. Доступные на данный момент варианты:
    * "PLOTTER" - выходные данные в формате плоттера: '$float_value index;', например - '$49.5 0;'
* <range_index> - индекс выбранного диапазона изменений в числовом формате согласно спецификации. например - '0'.
* <polling_period_ms> - период отправки значений датчика в непрерывном режиме. Формат - числовой, в миллисекундах. Пример - '500'.
  
Рассмотрим подробнее:
1. Запрос наличия и работоспособности MODUTE - классическая АТ-команда 'АТ'. MODULE должен ответить 'OK'.
2. **+SCFG** - параметры датчика(-ов) (Sensor ConFiGuration). Данная команда представлена в трёх типах: Test, Read и Set. В варианте Read MODULE должен вернуть значения параметров всех датчиков, параметры каждого датчика группируются в квадратные скобки [], разделитель - '&'. В варианте Set значения параметров присваиваются конкретному датчику по UUID и имени. 
3. **+PAS** - значения параметров текущего активного датчика (Parameters of Active Sensor). Данная команда представлена в двух типах: Test и Read. В варианте Read MODULE должен ответить в формате 'AT+PAS:<sensor_params>' если датчик активен, или "AT+PAS=\<"NONE"\>", если активных датчиков нет.
4. **+SGAS** - однократный запрос значений активного датчика (Single Get from Active Sensor). Данная команда представлена в двух типах: Test и Execution. В варианте Execution MODULE должен однократно передать значение(-я) датчика в специфическом data-формате, определённом в конфигурации датчика.
5. **+SPAS** - старт непрерывного опроса активного датчика (Start Polling of Active Sensor). Данная команда представлена в двух типах: Test и Execution. В варианте Execution MODULE должен начать передачу значения(-ий) датчика в специфическом data-формате в соответствии с установленным в конфигурации периодом опроса. Передача происходит до отмены этого режима или до перевода датчика в состояние 'OFF'.
6. **+BPAS** - остановка непрерывного опроса активного датчика (Break Polling of Active Sensor). Данная команда представлена в двух типах: Test и Execution. В варианте Execution MODULE должен остановить опрос датчика и ответить "OK".
***
Типичный порядок работы с датчиком:
<p align="center">
  <img src="/diagrams/protocol-flow.png">
</p>
