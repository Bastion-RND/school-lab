# Настоящий документ описывает протокол взаимодействия между головным устройством (далее - MASTER) и модулем расширения (далее - MODULE) от внешних разработчиков
***
## Соглашение о терминах
* ***Команда*** - инструкция для выполнения каких-либо действий;
* ***Ответ*** - отклик устройства, получившего определённую команду;
* ***Параметр*** - характеристика, определяющая поведение какого-либо объекта (например - датчика), которую можно прочитать и изменить;
* ***Данные*** - результат измерения датчика - физические единицы измеренной величины, представленные в виде числа с плавающей точкой;
* ***MASTER*** - ведущее устройство, обеспечивающее взаимодействие с приложением по Bluetooth и считывание данных с датчиков, а также фильтрацию и калибровку данных;
* ***MODULE*** - ведомое устройство, обеспечивающее работу с реальным физическим датчиком (датчиками) и нормирование "сырых" величин к виду данных.
***
## Характеристики системы \<MASTER-MODULE\>
* количество физических датчиков в рамках одного MODULE - от 1 и выше;
* количество каналов измерения в рамках одного датчика - от 1 и выше (например, акселерометер - трёхканальный);
* физический интерфейс для подключения MODULE к MASTER - UART в дуплексном режиме, скорость 115200, 8n1;
* управление потоком UART: RTS/CTS;
* протокол команд/ответов - АТ;
* протокол данных - строковый протокол плоттера.
***
## Протокол команд/ответов
MASTER отправляет в сторону MODULE команды и получает от MODULE ответы в формате протокола АТ. Протокол AT предполагает связь "точка-точка", одно устройство формирует запросы (ведущий, в нашем случае MASTER), второе устройство отвечает (ведомый, в нашем случае MODULE). Рассмотрим более подробно синтаксис АТ-команд:  
  
### Команды  
АТ-команда представляет собой строку ASCII-символов в формате  
> 'AT\<COMMAND\>\<SUFFIX\>\<PARAMS\>\r\n'  
  
В начале всегда идёт префикс 'AT', затем команда, далее - суффикс, определяющий тип команды, после - данные, в самом конце - завершающая последовательность '\r\n'. Особняком стоит специализированная команда, состоящая только из префикса 'AT'. Это команда для проверки связи с ведомым.
  
**ВНИМАНИЕ!** - далее, для упрощения, завершающая последовательность '\r\n' не показывается. Но она есть)  
  
В широком смысле, AT-команды можно разделить на два формата: **Basic Commands** и **Extended Commands**.
* **Basic Commands** - эти команды не начинаются с '+'. Пример: 'ATCFG'. 
* **Extended commands** - эти команды начинаются с '+'. Пример: 'AT+CFG'.
В настоящем протоколе все команды в формате Extended для упрощения парсинга.  
  
Кроме того, все АТ-команды делятся на 4 типа. Тип определяется суффиксом, согласно следующей таблице:

|Type      |Suffix | Назначение                               |
|----------|:-----:|------------------------------------------|
|Test      |=?     |Проверка поддержки ведомым данной команды |
|Read      |?      |Получение от ведомого параметров          |
|Set       |=      |Установка на ведомом параметров           |
|Execution |       |Запуск определённого действия             |
  
* **Test Commands** - эти команды позволяют узнать, поддерживает ли ведомый данную команду или нет. Синтаксис: 'AT<COMMAND>=?'. Пример: 'AT+CFG=?'.
* **Read Commands** - эти команды служат для получения параметров от ведомого. Синтаксис: 'AT<COMMAND>?'. Пример: 'AT+CFG?'.
* **Set Commands** - эти команды служат для установки параметров ведомого. Синтаксис: 'AT<COMMAND>=<par1>,<par2>,...,<parN>'. Пример: 'AT+CFG=1,"ON",9'.
* **Execution Commands** - эти команды запускают на ведомом определённые действия. Синтаксис: 'AT<COMMAND>'. Пример: 'AT+STRT'.

### Ответы
Ответ на команду также представляет собой строку ASCII-символов возвращаемых параметров в формате 'AT\<COMMAND\>:\<PARAMS\>\r\n', затем статус 'OK\r\n'. Если ответ не предполагает возврата каких-либо параметров, то сразу возвращается статус 'OK\r\n'. Если возврат параметров невозможен (был получен некорректный запрос от MASTER) или сама команда от MASTER ошибочна, то сразу возвращается статус 'ERROR\r\n'.  
  
**ВНИМАНИЕ!** - далее, для упрощения, завершающая последовательность '\r\n' не показывается. Но она есть)  
  
Ниже приведён список команд настоящего протокола и ожидаемые ответы:
|№  |Command from MASTER       |Command type |Response from MODULE                                                          |
|---|:------------------------:|-------------|:----------------------------------------------------------------------------:|
|1  |'AT'                      |Check        |'OK'                                                                          |
|2.1|'AT+SCFG=?'               |Test         |'OK'                                                                          |
|2.2|'AT+SCFG?'                |Read         |'AT+SCFG:[<sensor1_params>]&[<sensor2_params>]&[...]&[<sensorN_params>]' 'OK' |
|2.3|'AT+SCFG=<sensor_params>' |Set          |'OK' or 'ERROR'                                                               |
|3.1|'AT+PAS=?'                |Test         |'OK'                                                                          |  
|3.2|'AT+PAS?'                 |Read         |'AT+PAS:<sensor_params>' 'OK' or 'AT+PAS:"NONE"' 'OK'                         |
|4.1|'AT+SGAS=?                |Test         |'OK'                                                                          |  
|4.2|'AT+SGAS'                 |Execution    |'OK' \<data from active sensor\>                                              |
|5.1|'AT+SPAS=?'               |Test         |'OK'                                                                          |
|5.1|'AT+SPAS'                 |Execution    |'OK' \<data from active sensor\> \<data from active sensor\> ...              |
|6.1|'AT+BPAS=?'               |Test         |'OK'                                                                          |
|6.1|'AT+BPAS'                 |Execution    |'OK'                                                                          |

Требования к формату параметров:
* Допустимые типы параметров - строка, целочисленное число, число с плавающей точкой;
* Числовые параметры с плавающей точкой используют в качестве разделителя между целочисленной и дробной частями точку, например: '3.14';
* Строковые параметры должны быть заключены в двойные кавычки, например: '3.14, "string", 9.8'.

Разберём подробнее структуру данных с параметрами датчика <sensor_params>. Она выглядит так: \<name\>,\<uuid\>,\<state\>,\<data_format\>,\<range_index\>,\<polling_period_ms\>.
* \<name\> - имя датчика в строковом формате. Пример: "Accelerometer".
* \<uuid\> - стандартный UUID датчика в строковом формате. Пример: "ba575001-eca0-11ec-8ea0-1337ac062022".  
* \<state\> - состояние датчика в строковом формате. Доступны следующие состояния:
    * "OFF" - датчик не активен. Это состояние всех датчиков по умолчанию.
    * "ON" - датчик активен. Только **ОДИН** датчик может быть активен в текущий момент. Текущий активированный датчик автоматически выключается при включении следующего.
* <data_format> - формат данных для выходных данных датчика. Доступные на данный момент варианты:
    * "PLOTTER" - выходные данные в формате плоттера. О форматах данных написано ниже.
* <range_index> - индекс выбранного диапазона изменений в числовом формате согласно спецификации. например - '0'.
* <polling_period_ms> - период отправки значений датчика в непрерывном режиме. Формат - числовой, в миллисекундах. Пример - '500'.
  
Рассмотрим подробнее команды протокола:
1. Запрос наличия и работоспособности MODULE - классическая АТ-команда 'АТ'. MODULE должен ответить 'OK'.
2. **+SCFG** - параметры датчика(-ов) (Sensor ConFiGuration). Данная команда представлена в трёх типах: Test, Read и Set.
    * в варианте Test MODULE должен вернуть 'OK';
    * в варианте Read MODULE должен вернуть значения параметров всех датчиков, параметры каждого датчика группируются в квадратные скобки [], разделитель - '&', после следует 'OK';
    * в варианте Set значения параметров присваиваются конкретному датчику по UUID и имени и MODULE отвечает 'ОК' (если такое имя и/или UUID датчика найдены) или параметры игнорируются и MODULE отвечает 'ERROR' (если имя и/или UUID не найдены). 
3. **+PAS** - значения параметров текущего активного датчика (Parameters of Active Sensor). Данная команда представлена в двух типах: Test и Read.
    * в варианте Test MODULE должен вернуть 'OK';
    * в варианте Read MODULE должен ответить в формате 'AT+PAS:<sensor_params>' и 'OK' если датчик активен, или 'AT+PAS=\<"NONE"\>' и 'OK', если активных датчиков нет.
4. **+SGAS** - однократный запрос значений активного датчика (Single Get from Active Sensor). Данная команда представлена в двух типах: Test и Execution.
    * в варианте Test MODULE должен вернуть 'OK';
    * в варианте Execution MODULE должен однократно вернуть 'OK' и данные датчика в специфическом data-формате, определённом в конфигурации датчика.
5. **+SPAS** - старт непрерывного опроса активного датчика (Start Polling of Active Sensor). Данная команда представлена в двух типах: Test и Execution.
    * в варианте Test MODULE должен вернуть 'OK';
    * в варианте Execution MODULE должен однократно вернуть 'OK' и начать бесконечную передачу данных активного датчика в специфическом data-формате в соответствии с установленным в конфигурации периодом опроса. Передача происходит до отмены этого режима или до перевода датчика в состояние 'OFF'.
6. **+BPAS** - отмена непрерывного опроса активного датчика (Break Polling of Active Sensor). Данная команда представлена в двух типах: Test и Execution.
    * в варианте Test MODULE должен вернуть 'OK';
    * в варианте Execution MODULE должен остановить опрос датчика и вернуть 'OK'.
***
## Протокол данных
На данный момент поддерживаются следующие протоколы кодирования данных:
* "PLOTTER" - данный формат передаёт значения с плавающей точкой и индекс канала в виде ASCII-символов. Сообщение выглядит следующим образом - '$value_index;\r\n' для одноканального датчика (пример - '$3.14_0;\r\n')  и '$value1_index1 value2_index2 value3_index3 .... valueN_indexN;\r\n' для многоканального датчика (пример - '$3.14_0 2.22_1 5.55_2;\r\n'.
***
## О управлении потоком RTS/CTS
Настоящий протокол предполагает управление потоком со стороны MASTER. Это необходимо для того, чтобы можно было прервать передачу данных в режиме непрерывного опроса датчика. Таким образом, на стороне MASTER есть только выход RTS (ready to send), на стороне MODULE есть только вход CTS (clear to send).  
**ВАЖНО** - получив сигнал на прерывание передачи, MODULE должен очистить свой выходной буфер, чтобы его дальнейшие ответы не слились с данными
***
Типичный порядок работы с датчиком:
<p align="center">
  <img src="/diagrams/protocol-flow.png">
</p>
